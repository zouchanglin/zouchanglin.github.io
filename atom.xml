<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim&#39;s Blog</title>
  
  <subtitle>一枚野生程序员~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouchanglin.cn/"/>
  <updated>2021-02-20T11:18:36.381Z</updated>
  <id>https://zouchanglin.cn/</id>
  
  <author>
    <name>Tim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WLAN下进行adb调试</title>
    <link href="https://zouchanglin.cn/486253043.html"/>
    <id>https://zouchanglin.cn/486253043.html</id>
    <published>2021-02-19T07:15:22.000Z</published>
    <updated>2021-02-20T11:18:36.381Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Android调试桥(Android Debug Bridge，简称ADB)。本文主要是记录如何在WLAN网络下进行ABD连接设备以及一些常用的ADB命令，还有ADB的组成以及原理简要说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="https://zouchanglin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="开发工具" scheme="https://zouchanglin.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>组件化Gradle语法</title>
    <link href="https://zouchanglin.cn/3612843011.html"/>
    <id>https://zouchanglin.cn/3612843011.html</id>
    <published>2021-02-18T15:52:08.000Z</published>
    <updated>2021-02-20T06:12:49.384Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Gradle作为一款优秀的构建工具，也作为是目前Android主流的构建工具，不管是通过命令行还是通过GUI方式构建，背后都是通过Gradle来实现的，所以学习Gradle非常重要。无论是组件化、插件化、热修复等技术都需要对Gradle比较了解，不懂Gradle将无法完成上述事情，所以Gradle必须要学习。这篇文章主要是针对组件化的Android项目，如何使用Gradle完成公共配置项的抽取，Gradle如何定义Task，工程测试环境与正式环境的自动配置等内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程构建" scheme="https://zouchanglin.cn/categories/%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="https://zouchanglin.cn/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>纯手写路由框架实现Android组件化</title>
    <link href="https://zouchanglin.cn/2230187564.html"/>
    <id>https://zouchanglin.cn/2230187564.html</id>
    <published>2021-02-17T15:45:29.000Z</published>
    <updated>2021-02-20T14:05:54.370Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在非常简单的业务场景下，单一工程就可以实现一个完整的App，而且维护和开发都非常简单。但是当一个App涉及到很多功能，单一的Module显得很吃力。如果整个工程一个 Module，业务逻辑都写在app模块中不同的包下：无论分包做的再好，随着项目增大也会失去层次感，接手起来也很吃力；而且包名约定作为约束太弱，一不注意就出现不同业务包之间直接相互调用，代码高度耦合；多人联合开发在版本管理中很容易出现冲突和代码覆盖问题。那么就很容易出现下面的场景：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; when I wrote this, only god and I understood what I was doing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; Now, god only knows&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;本文主要围绕什么是组件化，为什么需要组件化，如何进行组件化展开。路由在Android组件化开发中的重要作用，分析路由框架的实现原理，如何一步一步实现一个路由框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="模块化" scheme="https://zouchanglin.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="组件化" scheme="https://zouchanglin.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Router" scheme="https://zouchanglin.cn/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>RISC汇编与中断向量表</title>
    <link href="https://zouchanglin.cn/439419438.html"/>
    <id>https://zouchanglin.cn/439419438.html</id>
    <published>2021-02-15T15:32:06.000Z</published>
    <updated>2021-02-16T10:17:13.023Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;摩尔定律让算力放缓，以前学习的都是32位的x86汇编，不得不说x86架构的指令集真的是历史包袱太重了，x86架构的不足在当代急需超强的算力的背景下越发明显，功耗大、通用寄存器数量少、计算机硬件利用率低、寻址范围小等问题凸显，难以跟上算力发展的速度。与此同时，ARM架构在移动互联网盛行的当下却开始焕发出别样的生命力。于是最近看了看ARM架构下的衍生RISC-V架构，顺便回顾一下计算机组成原理的相关内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zouchanglin.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="汇编语言" scheme="https://zouchanglin.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>设计一个简易图片缓存组件</title>
    <link href="https://zouchanglin.cn/2719388914.html"/>
    <id>https://zouchanglin.cn/2719388914.html</id>
    <published>2021-01-24T13:43:16.000Z</published>
    <updated>2021-02-02T07:52:00.828Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在UI界面加载一张图片时很简单，然而如果需要加载多张较大的图像，事情就会变得更加复杂。在许多情况下（如ListView、RecyclerView或ViewPager等的组件），屏幕上的图片的总数伴随屏幕的滚动会大大增加，且基本上是无限的。为了使内存使用保持在稳定范围内，防止出现OOM，这些组件会在子iew划出屏幕后，对其进行资源回收，并重新显示新出现的图片，垃圾回收机制会释放掉不再显示的图片的内存空间。但是这样频繁地处理图片的加载和回收不利于操作的流畅性，而内存或者磁盘的Cache就会帮助解决这个问题，实现快速加载已加载的图片。在缓存上，主要有两种级别的Cache：LruCache和DiskLruCache，即内存缓存与磁盘缓存。我们就来借助内存缓存和磁盘缓存来实现一个简易的图片缓存框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="LRUCache" scheme="https://zouchanglin.cn/tags/LRUCache/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView的应用</title>
    <link href="https://zouchanglin.cn/3653446494.html"/>
    <id>https://zouchanglin.cn/3653446494.html</id>
    <published>2021-01-24T08:48:13.000Z</published>
    <updated>2021-01-24T13:38:03.017Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;RecyclerView是Android 5.0以后提出的新UI控件，可以用来代替传统的ListView。但是RecyclerView并不会完全替代ListView，因为两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView， 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能，这是由于RecyclerView对各个功能进行解耦，从而相对于ListView有更好的拓展性。本篇文章着重讲述RecyclerView的使用方式方式上，以及和ListView的对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>EventBus的应用</title>
    <link href="https://zouchanglin.cn/1024374978.html"/>
    <id>https://zouchanglin.cn/1024374978.html</id>
    <published>2021-01-22T14:05:24.000Z</published>
    <updated>2021-01-23T16:47:18.104Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是GreenRobot开发的Android和Java的开源库，使用发布者/订阅者模式进行解耦合。EventBus使组件之间的通信只需几行代码即可搞定，极度解耦并且简化了代码，消除依赖关系并加快应用程序开发。这里是EventBus的官网：&lt;a href=&quot;https://greenrobot.org/eventbus/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://greenrobot.org/eventbus/&lt;/a&gt;。在介绍EventBus的通信方法之前，首先会介绍常规的通信方法，比如说设置监听或者是使用广播等方式，以此来说明常规的方法都有其弊端，然后使用EventBus来完成组件之间的通信，通过案例体会EventBus在组件通信过程中的优势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.zouchanglin.cn/20210123141351.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="消息通信" scheme="https://zouchanglin.cn/tags/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/"/>
    
      <category term="发布订阅" scheme="https://zouchanglin.cn/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    
  </entry>
  
  <entry>
    <title>自定义View（二）</title>
    <link href="https://zouchanglin.cn/1261209182.html"/>
    <id>https://zouchanglin.cn/1261209182.html</id>
    <published>2021-01-20T13:51:58.000Z</published>
    <updated>2021-01-20T15:42:27.806Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前面的文章介绍了自定义View的需要准备的基础知识，自定义View的属性获取、测量(Measure)过程，Measure过程是为了计算View的大小。本篇文章主要记载一下自定义View过程中的Layout过程，Layout过程用于计算View的位置。另外还有更关键的一步，那就是绘制(Draw)过程，一切都准备好了就需要开始绘制出我们的自定义View，后面会有一个绘制例子，在该示例中绘制了一个圆形且带有进度文字说明的进度条，通过这个示例切实感受一下自定义View的魅力。最后还有一个重点就是自定义View状态的存储与恢复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="自定义View" scheme="https://zouchanglin.cn/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>自定义View（一）</title>
    <link href="https://zouchanglin.cn/2067425926.html"/>
    <id>https://zouchanglin.cn/2067425926.html</id>
    <published>2021-01-18T14:35:20.000Z</published>
    <updated>2021-01-20T14:48:28.625Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;很多时候系统自带的View组件并不能满足我们的需求，当我们需要特定的显示风格，处理特有的用户交互，封装一个高内聚的视图组件，就需要用到Android给我们提供的自定义View的能力。有了自定义View，我们可以针对特定的应用场景开发出适合该场景的View组件，比如自定义的下拉刷新组件，自定义的进度条组件等等。本片文章主要介绍自定义View的基础知识，为自定义View做充足的准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="自定义View" scheme="https://zouchanglin.cn/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>HLS流媒体服务与加解密</title>
    <link href="https://zouchanglin.cn/901333507.html"/>
    <id>https://zouchanglin.cn/901333507.html</id>
    <published>2021-01-17T02:52:11.000Z</published>
    <updated>2021-01-17T13:48:18.289Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在前面一篇文章中&lt;a href=&quot;/3213001717.html&quot;&gt;《流媒体协议之HLS》&lt;/a&gt;介绍了什么是流媒体，什么是HLS以及分析了m3u8文件格式内容的含义。在本篇文章中更多的是实际操作，搭建一个流媒体服务，使用ffmpeg切割大的视频文件，使用ffmpeg切割大的视频文件并加密，使用ffmpeg整合视频片断，以及在代码中如何实现根据m3u8下载并解码对应的媒体文件。演示的环境是Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-62-generic x86_64)、nginx-1.19.6、gcc version 9.3.0、GNU Make 4.2.1O、OpenSSL 1.1.1f&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频技术" scheme="https://zouchanglin.cn/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="https://zouchanglin.cn/tags/Nginx/"/>
    
      <category term="流媒体" scheme="https://zouchanglin.cn/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
      <category term="ffmpeg" scheme="https://zouchanglin.cn/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>流媒体协议之HLS</title>
    <link href="https://zouchanglin.cn/3213001717.html"/>
    <id>https://zouchanglin.cn/3213001717.html</id>
    <published>2021-01-16T10:14:49.000Z</published>
    <updated>2021-01-16T16:56:34.426Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;流媒体（Streaming media）是指将一连串的多媒体资料压缩后，经过互联网分段发送资料，在互联网上即时传输影音以供观赏的一种技术与过程，此技术使得资料数据包得以像流水一样发送，如果不使用此技术，就必须在使用前下载整个媒体文件。实时流媒体是指互联网内容的实时传输，就像电视直播通过电视信号在电波上播放内容一样。互联网流媒体直播需要一种形式的源媒体（如摄像机、音频接口、屏幕捕捉软件）、将内容数字化的编码器、媒体发布者和内容传输网络来分发和传递内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频技术" scheme="https://zouchanglin.cn/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="流媒体" scheme="https://zouchanglin.cn/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
      <category term="m3u8" scheme="https://zouchanglin.cn/tags/m3u8/"/>
    
  </entry>
  
  <entry>
    <title>回顾我的2020</title>
    <link href="https://zouchanglin.cn/1099989216.html"/>
    <id>https://zouchanglin.cn/1099989216.html</id>
    <published>2021-01-16T07:14:55.000Z</published>
    <updated>2021-01-16T08:24:46.865Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;2021已经到来了15天了，时间过得真快呀。因为前两周实在是太忙了，所以在这个周末才打算写一篇博客回顾我的2020年，2020其实事情挺多的，而且在我自己看来，也是进步很大的一年，在多年以后看到这篇文章，也许就像品尝一坛老酒，清香醇厚。以后每一年我都会有自己的年终总结，回顾这一年发生的所有对于我来讲比较重要的事情，就像小学的时候写作文，像一本流水账，越清晰的流水账越历久弥新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://zouchanglin.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://zouchanglin.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>多仓库管理工具——Repo</title>
    <link href="https://zouchanglin.cn/4221524257.html"/>
    <id>https://zouchanglin.cn/4221524257.html</id>
    <published>2021-01-16T05:03:53.000Z</published>
    <updated>2021-01-16T07:11:38.803Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Repo 是建立在Git上的一个多仓库管理工具，可以组织多个仓库的上传和下载。Repo是Google用Python脚本写的调用Git的脚本，主要帮助我们管理多个Git存储仓库，将其上传到我们的版本控制系统，并自动执行Android开发工作流程的某些部分。Repo并不是要取代Git，而是为了在Android环境下更加方便的使用Git。下面来看看Repo的具体用法吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="版本控制" scheme="https://zouchanglin.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git" scheme="https://zouchanglin.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高效易用的IO库【Okio应用篇】</title>
    <link href="https://zouchanglin.cn/91228.html"/>
    <id>https://zouchanglin.cn/91228.html</id>
    <published>2020-12-12T15:58:23.000Z</published>
    <updated>2021-01-15T17:01:18.342Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp是Android中包含的功能强大的HTTP客户端，此框架平时用的还挺多的，但是今天的主角是OkHttp的低层IO库——Okio，Okio是对java.io和java.nio的补充，使访问、存储和处理数据变得更加容易。 这里是它的官网：&lt;a href=&quot;https://square.github.io/okio/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://square.github.io/okio/&lt;/a&gt; ， 最开始它作为OKHttp的一个组件，现在可以独立使用它来解决一些IO问题，接下来的内容来自对Okio官网的文档以及一些代码示例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高性能网络" scheme="https://zouchanglin.cn/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="序列化" scheme="https://zouchanglin.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="IO" scheme="https://zouchanglin.cn/tags/IO/"/>
    
      <category term="Stream" scheme="https://zouchanglin.cn/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Android Socket与HTTPS校验</title>
    <link href="https://zouchanglin.cn/64846.html"/>
    <id>https://zouchanglin.cn/64846.html</id>
    <published>2020-12-11T14:04:00.000Z</published>
    <updated>2020-12-11T14:08:26.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Android中使用HTTPS的场景比较频繁，所以对于HTTPS的证书应该如何校验呢？关于HTTPS的校验原理可以参考我之前写的一篇文章：&lt;a href=&quot;https://zouchanglin.cn/2020/02/25/1436780387.html&quot;&gt;《 HTTPS协议实现原理 》&lt;/a&gt;，相信看完后应该对HTTPS有一个比较大致的了解。而且对HTTP(s)请求的工具进行了封装，需要体会这种封装工具类的思路，也就是编码中常见的Listener机制。然后是Android中TCP、UDP通信的例子，主要是把Android设备作为Client端，如果对Java的Socket编程比较熟悉的话，这些都是特别简单的示例程序，非常容易看懂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="网络安全" scheme="https://zouchanglin.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="设计模式" scheme="https://zouchanglin.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>探究ContentProvider</title>
    <link href="https://zouchanglin.cn/24594.html"/>
    <id>https://zouchanglin.cn/24594.html</id>
    <published>2020-12-09T14:48:30.000Z</published>
    <updated>2020-12-09T15:00:22.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;为什么微信、QQ、淘宝等App都能访问联系人(通讯录)呢？是因为Android存在一种应用之间的数据共享机制，即ContentProvider，ContentProvider作为Android四大组件之一，为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。对于ContentProvier而言，无论数据的来源是什么，它都认为是种表（同时也支持文件数据，只是表格形式用得比较多），然后把数据组织成表格返回给使用者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="服务解耦" scheme="https://zouchanglin.cn/tags/%E6%9C%8D%E5%8A%A1%E8%A7%A3%E8%80%A6/"/>
    
      <category term="IPC通信" scheme="https://zouchanglin.cn/tags/IPC%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>远程服务使用AIDL通信</title>
    <link href="https://zouchanglin.cn/35923.html"/>
    <id>https://zouchanglin.cn/35923.html</id>
    <published>2020-12-08T16:17:00.000Z</published>
    <updated>2020-12-08T16:26:32.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Android 中，一个进程通常无法访问另一个进程的内存。因此为了进程间通信，Android提供了AIDL机制，AIDL是Android中IPC（Inter-Process Communication）方式中的一种，AIDL是Android Interface definition language的缩写，AIDL的作用是可以在自己的App里绑定一个其他App的Service，这样App可以通过AIDL与其他App进行交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="消息通信" scheme="https://zouchanglin.cn/tags/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>后台默默的劳动者，探究服务</title>
    <link href="https://zouchanglin.cn/53372.html"/>
    <id>https://zouchanglin.cn/53372.html</id>
    <published>2020-12-07T16:36:12.000Z</published>
    <updated>2020-12-08T01:50:12.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;服务作为Android四大组件之一，是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。需要注意的是服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的，所以需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="异步" scheme="https://zouchanglin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Application全局应用</title>
    <link href="https://zouchanglin.cn/12540.html"/>
    <id>https://zouchanglin.cn/12540.html</id>
    <published>2020-12-07T03:10:00.000Z</published>
    <updated>2020-12-07T09:18:04.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Application是维护应用全局状态的基类，Android系统会在启动应用进程时创建一个对应的Application对象。所以当我们需要创建全局变量的时候，不需要再像Java那样需要创建public权限的static变量，而直接在Application中去实现。其他组件只需要调用Context的getApplicationContext或者getApplication(在Activity中)来获得一个Application对象，再做出相应的处理。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="组件通信" scheme="https://zouchanglin.cn/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>全局大喇叭——BroadcastReceiver</title>
    <link href="https://zouchanglin.cn/17555.html"/>
    <id>https://zouchanglin.cn/17555.html</id>
    <published>2020-12-04T04:10:00.000Z</published>
    <updated>2020-12-04T06:30:14.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记述了Android的四大组件之一 —— BroadcastReceiver（广播接收者）。广播的作用、广播注册的方式、自定义广播、广播的类型以及在较新的Android系统中使用BroadcastReceiver需要注意的问题。Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与发布-订阅设计模式相似，这些广播会在所关注的事件发生时发送出去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动开发" scheme="https://zouchanglin.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://zouchanglin.cn/tags/Android/"/>
    
      <category term="消息通信" scheme="https://zouchanglin.cn/tags/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
</feed>
